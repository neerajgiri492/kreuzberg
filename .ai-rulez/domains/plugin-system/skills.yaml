skills:
  # Plugin Design & Implementation Skills
  - name: plugin-trait-implementation
    context: Implement plugins using trait interfaces
    key_source_files:
      - crates/kreuzberg/src/plugins/mod.rs (Plugin trait)
      - crates/kreuzberg/src/plugins/extractor.rs (DocumentExtractor trait)
    master_concepts:
      - Plugin trait structure
      - Lifecycle methods (initialize, shutdown)
      - Type-specific trait implementation
      - Thread safety requirements (Send + Sync)
      - Async trait support
    step_by_step: |
      1. Define plugin struct
      2. Implement Plugin base trait:
         - name() → String identifier
         - version() → String version
         - initialize() → setup resources
         - shutdown() → cleanup resources
      3. Implement type-specific trait:
         - DocumentExtractor
         - OcrBackend
         - PostProcessor
         - Validator
      4. Ensure Send + Sync implementation
      5. Handle lifecycle errors
      6. Test plugin lifecycle
    skills_involved:
      - trait-design
      - rust-async-patterns
      - resource-management
      - error-handling
    when_to_use: Creating new plugin implementations

  - name: document-extractor-plugin
    context: Implement custom document extractors
    key_source_files:
      - crates/kreuzberg/src/plugins/extractor.rs
    master_concepts:
      - DocumentExtractor trait implementation
      - MIME type declaration
      - Extraction algorithm implementation
      - ExtractionConfig usage
      - Result standardization
      - Error handling
      - Priority management
    step_by_step: |
      1. Create struct implementing DocumentExtractor
      2. Declare supported MIME types
      3. Set priority level (0-255)
      4. Implement extract_bytes():
         a. Accept bytes, MIME type, config
         b. Validate input
         c. Apply config options
         d. Perform extraction
         e. Return ExtractionResult
      5. Implement extract_file():
         a. Read file to bytes
         b. Call extract_bytes()
      6. Handle all error cases
      7. Validate result structure
      8. Test extraction quality
    skills_involved:
      - format-parsing
      - api-design
      - error-handling
      - performance-optimization
    when_to_use: Adding support for new document formats

  - name: ocr-backend-plugin
    context: Implement custom OCR backends
    key_source_files:
      - crates/kreuzberg/src/plugins/ocr.rs (OcrBackend trait)
    master_concepts:
      - OcrBackend trait implementation
      - Async image processing
      - Language support declaration
      - Capability declaration
      - TesseractConfig usage
      - Result standardization
    step_by_step: |
      1. Create struct implementing OcrBackend
      2. Initialize OCR model/engine
      3. Implement async process_image():
         a. Accept image bytes
         b. Extract language from config
         c. Validate image format
         d. Apply preprocessing if needed
         e. Run OCR engine
         f. Parse results
         g. Return ExtractionResult
      4. Implement supported_languages()
      5. Declare capabilities()
      6. Handle async execution
      7. Test OCR accuracy
      8. Benchmark performance
    skills_involved:
      - ocr-engine-integration
      - async-rust-patterns
      - image-processing
      - performance-tuning
    when_to_use: Integrating alternative OCR engines

  - name: python-plugin-wrapper
    context: Wrap Python plugins with Rust FFI
    key_source_files:
      - crates/kreuzberg-py/src/plugins.rs
    master_concepts:
      - PyO3 FFI bindings
      - Python object caching
      - GIL management patterns
      - Async Python method calls
      - Exception translation
    step_by_step: |
      1. Create wrapper struct holding Py<PyAny>
      2. Cache frequently-accessed data:
         - name
         - version
         - supported languages
      3. Implement initialize():
         - Acquire GIL with Python::attach()
         - Call Python __init__
         - Cache result
      4. Implement main async method:
         a. Clone Python object reference
         b. Spawn blocking task
         c. Acquire GIL inside task
         d. Call Python method
         e. Translate Python types to Rust
         f. Handle PyException
         g. Return Rust result
      5. Release resources in shutdown()
    skills_involved:
      - pyo3-usage
      - gil-management
      - async-patterns
      - type-conversion
      - exception-handling
    when_to_use: Creating Rust-Python FFI bindings

  # Registry & Management Skills
  - name: registry-implementation
    context: Build plugin registry systems
    key_source_files:
      - Plugin registry implementations (location TBD)
    master_concepts:
      - RwLock-based thread-safe storage
      - MIME type indexing
      - Priority sorting
      - Registration/unregistration
      - Query optimization
      - Consistency maintenance
    step_by_step: |
      1. Define registry struct:
         - Arc<RwLock<Vec<Plugin>>>
         - Arc<RwLock<HashMap<MimeType, Indices>>>
      2. Implement register():
         - Acquire write lock
         - Add to storage
         - Update indices
         - Release lock
      3. Implement get_for_capability():
         - Acquire read lock
         - Query indices
         - Sort by priority
         - Release lock
         - Return plugins
      4. Implement unregister():
         - Acquire write lock
         - Remove from storage
         - Update indices
      5. Implement clear():
         - Acquire write lock
         - Clear all data structures
      6. Test concurrent operations
    skills_involved:
      - concurrent-programming
      - data-structure-design
      - lock-patterns
      - performance-optimization
    when_to_use: Building plugin registry systems

  - name: priority-selection-system
    context: Implement priority-based plugin selection
    key_source_files:
      - Plugin selection logic
    master_concepts:
      - Priority levels (0-255)
      - Capability matching
      - Sorting algorithms
      - Fallback chains
      - Conflict resolution
    step_by_step: |
      1. Define priority semantics:
         - Higher = more priority
         - Default = 50 (middle)
         - Custom = > 50
         - Fallback = < 50
      2. Get matching plugins from registry
      3. Sort by priority (descending)
      4. For each plugin:
         a. Check if supports capability
         b. If not, try next
         c. If yes, attempt operation
         d. On success, return
         e. On failure, try next (fallback)
      5. Return best result or error
      6. Document priority decisions in logs
    skills_involved:
      - algorithm-design
      - sorting-optimization
      - fallback-logic
      - error-aggregation
    when_to_use: Selecting plugins from multiple options

  - name: plugin-discovery
    context: Discover and load plugins dynamically
    key_source_files:
      - Plugin discovery mechanisms
    master_concepts:
      - Module scanning
      - Class detection
      - Trait validation
      - Plugin instantiation
      - Error handling
    step_by_step: |
      1. For static Rust plugins:
         a. Create plugin instance
         b. Validate implements traits
         c. Register with registry
      2. For Python plugins:
         a. Scan module paths
         b. Import modules
         c. Find plugin classes
         d. Validate implements protocol
         e. Instantiate with PyO3
         f. Register with registry
      3. Validate before registration:
         - Check required methods exist
         - Verify method signatures
         - Test initialization
      4. Handle discovery errors gracefully
      5. Report unregistered plugins
    skills_involved:
      - module-loading
      - reflection-patterns
      - validation-logic
      - error-handling
    when_to_use: Loading plugins dynamically

  - name: gil-management-patterns
    context: Manage Python GIL efficiently
    key_source_files:
      - crates/kreuzberg-py/src/plugins.rs (GIL patterns section)
    master_concepts:
      - GIL acquisition/release
      - Python::attach() for quick operations
      - py.detach() for expensive operations
      - tokio::task::spawn_blocking for async
      - Data caching strategies
      - Performance implications
    step_by_step: |
      1. For quick Python operations:
         ```rust
         Python::attach(|py| {
             let result = obj.bind(py).call_method0("name")?;
             result.extract::<String>()
         })
         ```
      2. For expensive Rust operations:
         ```rust
         py.detach(|| {
             let registry = get_registry();
             registry.write()?.register(plugin)
         })
         ```
      3. For async Python calls:
         ```rust
         let py_obj = Python::attach(|py| py_obj.clone_ref(py));
         tokio::task::spawn_blocking(move || {
             Python::attach(|py| py_obj.bind(py).call(...))
         }).await?
         ```
      4. Cache frequently-accessed Python data
      5. Measure GIL overhead impact
    skills_involved:
      - pyo3-patterns
      - async-rust
      - performance-tuning
      - profiling-tools
    when_to_use: Optimizing Python-Rust FFI performance

  # Configuration & Behavior Skills
  - name: plugin-configuration
    context: Design plugin configuration systems
    key_source_files:
      - Configuration structures in plugins
    master_concepts:
      - Config schema design
      - Serialization (serde)
      - Validation logic
      - Per-plugin configuration
      - Config cascade from ExtractionConfig
    step_by_step: |
      1. Define config struct:
         ```rust
         #[derive(Deserialize)]
         pub struct MyPluginConfig {
             pub option1: String,
             pub option2: u32,
         }
         ```
      2. Implement validation:
         ```rust
         impl MyPluginConfig {
             pub fn validate(&self) -> Result<()> { ... }
         }
         ```
      3. Pass to plugin during execution
      4. Plugin applies configuration
      5. Document config options
      6. Provide examples
      7. Test config impact
    skills_involved:
      - config-design
      - validation-logic
      - api-documentation
      - testing-strategies
    when_to_use: Designing plugin configuration systems

  - name: plugin-lifecycle-management
    context: Manage plugin initialization and shutdown
    key_source_files:
      - Plugin lifecycle in trait definitions
    master_concepts:
      - Initialize method for setup
      - Shutdown method for cleanup
      - Error handling
      - Resource management
      - State tracking
    step_by_step: |
      1. In initialize():
         a. Load resources (models, configs)
         b. Validate dependencies
         c. Set up connections
         d. Return error if failure
      2. Track plugin state (ready, error)
      3. In shutdown():
         a. Release resources
         b. Close connections
         c. Persist state if needed
         d. Return error if failure
      4. Test lifecycle with cleanup verification
      5. Handle errors during both phases
    skills_involved:
      - resource-management
      - error-handling
      - state-management
      - testing-strategies
    when_to_use: Implementing plugin initialization and cleanup

  # Error Handling & Resilience Skills
  - name: plugin-error-handling
    context: Handle plugin errors and implement recovery
    key_source_files:
      - Error handling throughout plugin system
    master_concepts:
      - Error type classification
      - Error context preservation
      - Fallback strategies
      - User-friendly messages
      - Error propagation
    step_by_step: |
      1. Classify plugin errors:
         - InitializationError
         - ExecutionError
         - ConfigurationError
      2. Catch plugin exceptions
      3. Wrap in KreuzbergError with context
      4. Preserve original error information
      5. Implement fallback:
         a. Try next-priority plugin
         b. Return partial result if available
         c. Log error for debugging
      6. Return structured error to user
    skills_involved:
      - error-design
      - exception-handling
      - logging-strategies
      - recovery-logic
    when_to_use: Improving plugin error handling

  - name: fallback-chain-implementation
    context: Implement fallback execution chains
    key_source_files:
      - Fallback logic in registry/selection
    master_concepts:
      - Primary → secondary → tertiary execution
      - Error accumulation
      - Partial result handling
      - Logging at each step
      - Chain termination strategies
    step_by_step: |
      1. Get ordered list of plugins (by priority)
      2. For each plugin:
         a. Attempt operation
         b. On success, return result
         c. On error:
            i. Log error details
            ii. Store error for aggregation
            iii. Try next plugin
      3. After all attempts:
         a. If any succeeded, return best result
         b. If all failed, aggregate errors
         c. Return structured error
      4. For batch operations:
         a. Continue with remaining items
         b. Track per-item errors
         c. Return partial results with errors
    skills_involved:
      - error-aggregation
      - logging-design
      - result-composition
      - batch-processing
    when_to_use: Implementing robust fallback strategies

  # Testing & Validation Skills
  - name: plugin-testing-framework
    context: Test plugins and plugin system
    key_source_files:
      - Test utilities for plugins
    master_concepts:
      - Unit tests for plugin logic
      - Integration tests with registry
      - Mock plugin implementations
      - Concurrent access testing
      - Performance testing
    step_by_step: |
      1. Create mock plugin implementations
      2. Unit test plugin logic:
         - Input validation
         - Output correctness
         - Error cases
      3. Integration test with registry:
         - Registration/unregistration
         - Query operations
         - Priority selection
      4. Test concurrent access:
         - Multiple threads accessing registry
         - Plugin execution concurrency
         - Lock contention
      5. Performance test:
         - Registration speed
         - Selection speed
         - Memory usage
      6. Test error scenarios:
         - Plugin initialization failure
         - Plugin execution failure
         - Missing dependencies
    skills_involved:
      - test-design
      - mock-objects
      - concurrent-testing
      - performance-testing
    when_to_use: Testing plugins and plugin system

  - name: mock-plugin-creation
    context: Create mock plugins for testing
    key_source_files:
      - Test utilities
    master_concepts:
      - Simple plugin implementations
      - Configurable behavior
      - Error injection
      - Performance simulation
    step_by_step: |
      1. Create simple test plugin:
         ```rust
         struct MockExtractor {
             result: ExtractionResult,
         }
         ```
      2. Implement required traits
      3. Configure behavior:
         - Success/failure
         - Execution time
         - Output content
      4. Use for testing registry
      5. Use for testing selection logic
      6. Use for testing fallback chains
    skills_involved:
      - test-utilities
      - mock-implementation
      - behavior-configuration
    when_to_use: Creating test plugins

  - name: performance-profiling-plugins
    context: Profile plugin performance
    key_source_files:
      - Profiling tools and benchmarks
    master_concepts:
      - Execution time measurement
      - Memory usage tracking
      - GIL overhead analysis
      - Lock contention measurement
      - Bottleneck identification
    step_by_step: |
      1. Measure plugin registration time
      2. Measure selection overhead
      3. Measure plugin execution time
      4. Profile GIL usage (for Python plugins):
         - GIL hold time
         - Frequency of acquisition
         - Release efficiency
      5. Profile memory usage:
         - Plugin memory footprint
         - Data structure sizes
         - Cache sizes
      6. Identify bottlenecks
      7. Implement optimizations
      8. Verify improvements
    skills_involved:
      - profiling-tools
      - performance-analysis
      - optimization-techniques
    when_to_use: Optimizing plugin system performance
